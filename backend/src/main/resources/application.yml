spring:
  application:
    name: pim-backend

  datasource:
    url: ${SPRING_DATASOURCE_URL:jdbc:postgresql://localhost:5432/pim}
    username: ${SPRING_DATASOURCE_USERNAME:pim}
    # SECURITY: Password must be provided via environment variable in production
    password: ${SPRING_DATASOURCE_PASSWORD:}
    driver-class-name: org.postgresql.Driver
    # HikariCP Connection Pool Configuration
    hikari:
      # Maximum number of connections in the pool
      maximum-pool-size: ${DB_POOL_MAX_SIZE:20}
      # Minimum number of idle connections maintained
      minimum-idle: ${DB_POOL_MIN_IDLE:5}
      # Maximum time to wait for a connection from the pool (30 seconds)
      connection-timeout: ${DB_CONNECTION_TIMEOUT:30000}
      # Maximum idle time for connections (10 minutes)
      idle-timeout: ${DB_IDLE_TIMEOUT:600000}
      # Maximum lifetime of a connection in the pool (30 minutes)
      max-lifetime: ${DB_MAX_LIFETIME:1800000}
      # Connection validation timeout (5 seconds)
      validation-timeout: ${DB_VALIDATION_TIMEOUT:5000}
      # Leak detection threshold (0 = disabled, recommended for dev only)
      leak-detection-threshold: ${DB_LEAK_DETECTION_THRESHOLD:0}

  jpa:
    hibernate:
      # SECURITY: Use 'validate' in production, 'update' only for development
      ddl-auto: ${JPA_DDL_AUTO:validate}
    show-sql: false
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
        format_sql: false

  flyway:
    enabled: ${FLYWAY_ENABLED:true}

  # Cache Configuration
  cache:
    type: ${CACHE_TYPE:simple}  # 'simple' for in-memory, 'redis' for Redis

  # Redis Configuration (when cache.type=redis)
  data:
    redis:
      host: ${REDIS_HOST:localhost}
      port: ${REDIS_PORT:6379}
      password: ${REDIS_PASSWORD:}
      # Connection timeout (increased for network latency)
      timeout: ${REDIS_TIMEOUT:5000ms}
      # Command execution timeout
      lettuce:
        pool:
          # Maximum active connections
          max-active: ${REDIS_POOL_MAX_ACTIVE:16}
          # Maximum idle connections
          max-idle: ${REDIS_POOL_MAX_IDLE:8}
          # Minimum idle connections (pre-warmed for faster startup)
          min-idle: ${REDIS_POOL_MIN_IDLE:2}
          # Maximum wait time for connection (10 seconds, prevent thread starvation)
          max-wait: ${REDIS_POOL_MAX_WAIT:10000ms}

  # Elasticsearch Configuration
  elasticsearch:
    uris: ${ELASTICSEARCH_URIS:http://localhost:9200}

# Elasticsearch Custom Configuration
elasticsearch:
  enabled: ${ELASTICSEARCH_ENABLED:false}
  host: ${ELASTICSEARCH_HOST:localhost}
  port: ${ELASTICSEARCH_PORT:9200}
  username: ${ELASTICSEARCH_USERNAME:}
  password: ${ELASTICSEARCH_PASSWORD:}
  # Connection timeouts (milliseconds)
  connect-timeout: ${ELASTICSEARCH_CONNECT_TIMEOUT:5000}
  socket-timeout: ${ELASTICSEARCH_SOCKET_TIMEOUT:10000}

# Kafka Configuration
kafka:
  enabled: ${KAFKA_ENABLED:false}
  # Listener concurrency (number of parallel consumers)
  listener-concurrency: ${KAFKA_LISTENER_CONCURRENCY:3}

spring.kafka:
  bootstrap-servers: ${KAFKA_BOOTSTRAP_SERVERS:localhost:9092}
  consumer:
    group-id: ${KAFKA_CONSUMER_GROUP:pim-group}
    auto-offset-reset: earliest
    enable-auto-commit: false
    key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
    value-deserializer: org.springframework.kafka.support.serializer.JsonDeserializer
    properties:
      spring.json.trusted.packages: com.pim.domain.event,com.pim.infrastructure.messaging
  producer:
    key-serializer: org.apache.kafka.common.serialization.StringSerializer
    value-serializer: org.springframework.kafka.support.serializer.JsonSerializer
    acks: all
    retries: 3
    properties:
      enable.idempotence: true

  servlet:
    multipart:
      max-file-size: 50MB
      max-request-size: 50MB

server:
  port: 8080

# MinIO Configuration
minio:
  endpoint: ${MINIO_ENDPOINT:http://localhost:9000}
  access-key: ${MINIO_ACCESS_KEY:}
  # SECURITY: Must be provided via environment variable
  secret-key: ${MINIO_SECRET_KEY:}
  bucket-name: pim-assets

# JWT Configuration
jwt:
  # SECURITY: Secret MUST be provided via environment variable
  # Generate with: openssl rand -base64 64
  secret: ${JWT_SECRET:}
  # Token expiration: 1 hour (3600000ms) - shorter is more secure
  expiration: ${JWT_EXPIRATION:3600000}

# Security Configuration
security:
  rate-limit:
    requests-per-minute: ${SECURITY_RATE_LIMIT_REQUESTS_PER_MINUTE:60}
    login-attempts: ${SECURITY_RATE_LIMIT_LOGIN_ATTEMPTS:5}
    lockout-duration-minutes: ${SECURITY_RATE_LIMIT_LOCKOUT_DURATION_MINUTES:15}

# CORS Configuration
cors:
  allowed-origins: ${CORS_ALLOWED_ORIGINS:http://localhost:3000,http://localhost:3001}

# Media Upload Configuration
media:
  upload:
    path: ${MEDIA_UPLOAD_PATH:./uploads}
  base:
    url: ${MEDIA_BASE_URL:http://localhost:8080/uploads}

# OpenAPI
springdoc:
  api-docs:
    path: /api-docs
  swagger-ui:
    path: /swagger-ui.html

# Actuator & Metrics
management:
  endpoints:
    web:
      # Base path for actuator endpoints
      base-path: /actuator
      exposure:
        # Only expose health and info by default
        # Prometheus/metrics endpoints should be behind firewall or auth
        include: ${ACTUATOR_ENDPOINTS:health,info}
  endpoint:
    health:
      # Only show details to authenticated users
      show-details: when_authorized
      # Show components status
      show-components: when_authorized
    caches:
      enabled: true
    # Prometheus endpoint disabled by default for security
    prometheus:
      enabled: ${ACTUATOR_PROMETHEUS_ENABLED:false}
  # Health probes for Kubernetes
  health:
    livenessState:
      enabled: true
    readinessState:
      enabled: true
  metrics:
    tags:
      application: ${spring.application.name}
    export:
      prometheus:
        enabled: ${ACTUATOR_PROMETHEUS_ENABLED:false}

# Logging
logging:
  level:
    root: INFO
    com.pim: ${LOG_LEVEL_APP:DEBUG}
    # SECURITY: Don't log security details in default profile
    org.springframework.security: ${LOG_LEVEL_SECURITY:INFO}
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n"

---
spring:
  config:
    activate:
      on-profile: dev

  jpa:
    show-sql: true

logging:
  level:
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql: TRACE
    org.springframework.cache: TRACE

---
spring:
  config:
    activate:
      on-profile: prod

  cache:
    type: redis

  jpa:
    show-sql: false

kafka:
  enabled: true

# Production: Enable Prometheus for monitoring
management:
  endpoints:
    web:
      exposure:
        include: health,info,prometheus
  endpoint:
    prometheus:
      enabled: true
  metrics:
    export:
      prometheus:
        enabled: true

logging:
  level:
    root: WARN
    com.pim: INFO
    # Disable security debug in production
    org.springframework.security: WARN
    org.springframework.cache: INFO
    org.springframework.kafka: INFO

---
spring:
  config:
    activate:
      on-profile: test

  datasource:
    url: jdbc:tc:postgresql:16:///pim_test
    driver-class-name: org.testcontainers.jdbc.ContainerDatabaseDriver

  cache:
    type: simple

  jpa:
    hibernate:
      ddl-auto: create-drop
    show-sql: false

logging:
  level:
    root: WARN
    com.pim: DEBUG
